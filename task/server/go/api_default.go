/*
 * API Avito shop
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"net/http"
	"time"
)

type DefaultAPI struct {
	DB       *gorm.DB
	JWTToken []byte
}

// Post /api/auth
// Аутентификация и получение JWT-токена. При первой аутентификации пользователь создается автоматически.
func (api *DefaultAPI) ApiAuthPost(c *gin.Context) {
	var req AuthRequest

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload"})
		return
	}

	token, err := AuthOrRegisterUser(api.DB, req, api.JWTToken)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Возвращаем JWT-токен в ответе.
	c.JSON(http.StatusOK, gin.H{"token": token})
}

// Get /api/buy/:item
// Купить предмет за монеты.
func (api *DefaultAPI) ApiBuyItemGet(c *gin.Context) {
	userIDVal, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var uid int
	switch v := userIDVal.(type) {
	case float64:
		uid = int(v)
	case int:
		uid = v
	default:
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user id"})
		return
	}

	itemName := c.Param("item")
	if itemName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Item parameter is required"})
		return
	}

	err := api.DB.Transaction(func(tx *gorm.DB) error {
		var product Products
		if err := tx.Where("name = ?", itemName).First(&product).Error; err != nil {
			return err
		}

		var user User
		if err := tx.Where("id = ?", uid).First(&user).Error; err != nil {
			return err
		}

		if user.Balance < product.Price {
			return errors.New("not enough coins")
		}

		user.Balance -= product.Price
		if err := tx.Save(&user).Error; err != nil {
			return err
		}

		// Если запись для данного товара уже существует, увеличиваем количество, иначе создаём новую запись.
		var inv Inventory
		if err := tx.Where("user_id = ? AND item_type = ?", uid, product.Name).First(&inv).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				inv = Inventory{
					UserID:   uid,
					ItemType: product.Name,
					Quantity: 1,
				}
				if err := tx.Create(&inv).Error; err != nil {
					return err
				}
			} else {
				return err
			}
		} else {
			inv.Quantity++
			if err := tx.Save(&inv).Error; err != nil {
				return err
			}
		}

		return nil
	})

	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "purchase successful"})
}

// Get /api/info
// Получить информацию о монетах, инвентаре и истории транзакций.
func (api *DefaultAPI) ApiInfoGet(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	switch v := userID.(type) {
	case float64:
		userID = int(v)
	case int:
		userID = v
	default:
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user id"})
		return
	}

	var user User
	if err := api.DB.Table("users").
		Where("id = ?", userID).
		Scan(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get balance"})
		return
	}

	var inventory []Inventory
	if err := api.DB.Model(&Inventory{}).
		Where("user_id = ?", userID).
		Select("item_type, quantity").
		Find(&inventory).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get inventory"})
		return
	}

	var inventoryResp []InfoResponseInventoryInner
	for _, item := range inventory {
		inventoryResp = append(inventoryResp, InfoResponseInventoryInner{
			Type:     item.ItemType,
			Quantity: item.Quantity,
		})
	}

	var coinReceivedHistory []InfoResponseCoinHistoryReceivedInner
	if err := api.DB.Table("coin_histories").
		Joins("JOIN users ON coin_histories.from_user_id = users.id").
		Where("coin_histories.to_user_id = ?", userID).
		Select("users.username as from_user, coin_histories.amount").
		Find(&coinReceivedHistory).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get received coin history"})
		return
	}

	var coinSentHistory []InfoResponseCoinHistorySentInner
	if err := api.DB.Table("coin_histories").
		Joins("JOIN users ON coin_histories.to_user_id = users.id").
		Where("coin_histories.from_user_id = ?", userID).
		Select("users.username as to_user, coin_histories.amount").
		Find(&coinSentHistory).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get sent coin history"})
		return
	}

	c.JSON(http.StatusOK, InfoResponse{
		Coins:     int32(user.Balance),
		Inventory: inventoryResp,
		CoinHistory: InfoResponseCoinHistory{
			Received: coinReceivedHistory,
			Sent:     coinSentHistory,
		},
	})
}

// Post /api/sendCoin
// Отправить монеты другому пользователю.
func (api *DefaultAPI) ApiSendCoinPost(c *gin.Context) {
	userIDVal, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	var senderID int
	switch v := userIDVal.(type) {
	case float64:
		senderID = int(v)
	case int:
		senderID = v
	default:
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user id"})
		return
	}

	var req SendCoinRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload"})
		return
	}

	if req.Amount <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Amount must be greater than zero"})
		return
	}

	err := api.DB.Transaction(func(tx *gorm.DB) error {
		var sender User
		if err := tx.Where("id = ?", senderID).First(&sender).Error; err != nil {
			return err
		}

		if sender.Balance < int(req.Amount) {
			return errors.New("not enough coins")
		}

		var receiver User
		if err := tx.Where("username = ?", req.ToUser).First(&receiver).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return errors.New("receiver not found")
			}
			return err
		}

		if sender.ID == receiver.ID {
			return errors.New("sorry! You can't send coins to yourself")
		}

		sender.Balance -= int(req.Amount)
		receiver.Balance += int(req.Amount)

		if err := tx.Save(&sender).Error; err != nil {
			return err
		}
		if err := tx.Save(&receiver).Error; err != nil {
			return err
		}

		coinTransaction := CoinHistory{
			FromUserID: sender.ID,
			ToUserID:   receiver.ID,
			Amount:     int(req.Amount),
			Timestamp:  time.Now(),
		}
		if err := tx.Create(&coinTransaction).Error; err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "coins sent successfully"})
}
